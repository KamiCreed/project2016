<h1 id="asdf">This is where the game will go</h1>
<p id="additional" style="font-size: 20px; color: red; text-align: center">  </p>

<!-- Style the game display canvas however you wish by syling the 'Game' id -->
<div id="Game" style="padding: 10px;">
    
    <script>
        
        //create instance of the game engine.
        //This creates the canvas for the game to display, and allows you to use the Phaser engine
        var game = new Phaser.Game(800, 600, Phaser.AUTO, 'Game');
        
        //Returns a random integer between min (inclusive) and max (inclusive)
        function getRandomInt(min, max) {
            
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        function clamp(number, min, max) {
            
            return Math.max(min, Math.min(number, max));
        }
        
        //given an attacker's power attribute, and a defender's defense attribute, this function will calculate the damage received by teh defender
        //attackPower is a number, and you can use any entity attribute to represent the power
        //for example, a normal attack might use an etities strength, while a magic attack might use their magic power
        //same applies for the defender
        //this is a general use function meant to calcualte damage for any time of object
        //this can be extended to incorporate a damage range so it can calculate a random damage
        function determineDamage(attackPower, defenderDefense) {
            
            return Math.floor(clamp(attackPower - defenderDefense / 2, 1, attackPower));
        }
        
        function rpgEntity() {
            
            this.health = 20;
            this.strength = 10;
            this.defense = 10;
            this.level = 1;
            this.name = "Player";
            
            //last used attack is the attribtues of the attack last used by this entity
            //this is used to save data about an attack, which is used for damage calculation during the damage calculation state
            this.lastUsedAttack = {
                
                //must set this whenever the entity attacks
                //feel free to add other traits at any time
                power: 10,
            };
        };
        
        rpgEntity.prototype.getHit = function(damageReceived) {
            
            this.health = clamp(this.health - damageReceived, 0, this.health);
        }
        
        //define a global player variable
        //players will be global since Phaser deletes objects after a game state has ended (see below for explanation of game state)
        //We don't want to have to recreate a player object every single time we end a battle, so we will make a global player
        var player = new rpgEntity();//{
            
            //players will have various stats, these will be loaded from the rails data base
            //for now all we have is the player's sprite, which is a phaser game object that handles drawing/movement, and other great stuff
            //we don't actually need to put this since we can add it later
            //sprite: 0,
            
            //we will also have other stats about the player, read for the data base. uncomment later as needed
            /*
            anything with @player should be embeded ruby, right now leave it unembed
            
            this.level = @player.level
            this.health = ...
            ...
            ...
            */
        //};
        
        //create all of the required game states
        //A game state is basically a collection of all of the objects that are currently on screen
        //It also includes all the available functionality at any given time
        //for example, games can have a menu state, here the users can click on different buttons to go to different screens
        //it can have a gameplay state, where the actual gameplay happens
        
        //Game states will progress as follows:
        //start with the boot state, when the game first runs, we need to configure the screen size, and all other display information
        //this state handles screen set up, and nothing else
        var bootState = {
            
            //phaser allows users to specify special functiosn which are called during the game loop
            //for more information, check out: http://www.html5gamedevs.com/topic/1372-phaser-function-order-reserved-names-and-special-uses/
            create: function() {
                
                //define how the system should behave
                //use the arcade physics engine for collisin handling
                //I think p2 physics might be better because it offers pixel perfect collision detection, but we might not even need that so for now lets stick to somethign simple
                game.physics.startSystem(Phaser.Physics.ARCADE);
                
                //we're done with this state, so let's go onto the loading state to load the game resources
                game.state.start('load');
            },
        };
        
        //loading state should load ALL of the game's resources
        //this will cache (store in memory) all of the required pictures, sounds, level data for later use
        //this state is also where we generate the game world based on the players location
        //cached data will be saved to the global game object, so we can use it in later states
        var loadState = {
            
            //place to load files
            preload: function() {
                
                //loading is done using the following function
                //game.load.*   where * represents an object type to load
                //IMPORTANT: LOOK AT HOW WE GET THE PATH TO RESOURCE FILES, WE HAVE TO USE EMBED RUBY TO GENERATE THE PATH TO IT
                
                //load test player sprite sheet
                //remeber that the first parameter is always a hash key to refer to this object later
                //look at the documentation for all the parameters
                game.load.spritesheet('player', '<%= asset_path("roshan.png") %>', 32, 48);
                
                //since a player's game map is dependent on thier real world location, the map we load will depend on their location
                //so here is where we specify what map to load
                //we will assume mapWorldToGame will take a real world coordinate, and return an ingame map ID
                //we will also assume that all of our maps will be named mapI, where I is the map's id as a number
                
                //var mapId = mapWorldToGame(@player.realWorldLocation.x, @player.realWorldLocation.y);
                //var mapName = 'map' + mapId.toString();
                
                //now we load the tile set
                //tile maps will be created in the Tiled Level editor, which will give us a JSON file
                //we should use mapName instead of map.json, but we haven't created the map funcitonality so for now just use a preset level
                game.load.tilemap('level', '<%= asset_path("map.json") %>', null, Phaser.Tilemap.TILED_JSON);
                
                //we also want to load all the possible types of monsters in this level
                //we can assume that the getMonstersInMap will receive the name of a map, and returns the name of the file containing an array of monster names that can spawn on that map
                //These monster names will be used as keys into the mosnter database, and we will use it to retreive a given monster
                
                //var monsterListFile = getMonstersInMap(mapName)
                
                //now load this array for later use
                game.load.json('monsterList', '<%= asset_path("monsterList.json") %>');
                
                //now we have to load the actual mosnter database
                //this could also be stored in the server as a database, and we can use AJAX calls to receive the data
                //but for now i've saved all the mosnter data into app/assets/monsters/monsters.json
                game.load.json('monsterData', '<%= asset_path("monsters.json") %>');
                
                //now we would load all the images for the mosnters, but for now just load the orc image because i don't have any other mosnters
                game.load.image('orc','<%= asset_path("orc.png") %>' )
                
                //the above just loads the json file, but doens't load the tileSheet (the images used to draw every single tile)
                //here we load the tile image
                //again we would be using the mapName variable if it was set up
                game.load.image('tileset', '<%= asset_path("TileSet.png") %>');
                
            },
            
            //create function creats the required object for this game state
            create: function() {
                
                //create a text that says loading
                //very simple loading screen
                var style = { font: "bold 32px Arial", fill: "#fff", boundsAlignH: "center", boundsAlignV: "middle"};
        		this.text = game.add.text(0, 0, "loading", style);
                
                //HERE IS WHERE WE WILL LOAD THE PLAYER
                //the player is created here and used in all later states
                player.sprite = game.add.sprite(0, 0, 'player', 0);
                
                //we want player to actually collide with stuff, so add a physcis body
                game.physics.arcade.enable(player.sprite);
                
                //modify the player's hitbox so it doesn't look like he is collidig with thin air
                player.sprite.body.setSize(26, 18, 3, 30);
                
                //prevent the player from leaving the world bounds, this means that player's can't walk off the edge of teh screen
                player.sprite.body.collideWorldBounds = true;
                
                //add all of the player's animations
        		player.sprite.animations.add('left', [4, 5, 6, 7], 10, true);
        		player.sprite.animations.add('right', [8, 9, 10, 11], 10, true);
        		player.sprite.animations.add('up', [12, 13, 14, 15], 10, true);
        		player.sprite.animations.add('down', [0, 1, 2, 3], 10, true);
        		player.sprite.animations.add('attack', [4, 5, 6, 7, 4, 5, 6, 7, 4], 7, false);
        		
        		//right now the player will draw onto the screen since phaser automatically draws all new sprites
        		//we want to not draw the player to the screen, so we remove him from phaser's rendering list
        		//also once the Load state finishes, the player's sprite will automatically be destoryed by phaser, 
        		//but we want to keep the sprite for the actual gameplay state
        		//by removing player from the object list, we prevent him from being drawn, as well as being destoryed.
        		game.world.remove(player.sprite);
        		
        		//all obejcts have been loaded and created, so now we can start the game
        		game.state.start('overworld');
            },
        };
        
        //the gameplay state
        //this is where the player will move around on the map
        //the technical term is overworld, so thats the name i will use for this state
        var overworldState = {
            
            generateTilemap: function() {
                
                //we already loaded the tilemap data in the load state, we just need to set them to a phaser object
                this.map = game.add.tilemap('level');
                
                //we have loaded the tile data, but we haven't given it an image to use
                //here we set an image for each tileset in the tilemap (a tileset is an image containing all of the tiles for a given level)
                //every map has different tile sets, and each of these tilesets have their own names, the names are set using Tiled level editor,
                //and they can be viewd in the map.json file, under tilesets: name:
                //here we match the name of the tileset, to the name of a preloaded tileset image
                //since i named the tileset and the image the same thing, you won't be able to tell which name refers to what
                //the first argument is the name of the tileset that was set in the Tiled level editor
                //the second argument is the key to an image that was loaded by in the load state
                this.map.addTilesetImage('TileSet', 'tileset');
                
                //the tilemaps have been created, but they won't draw until we turn them into viewable layers
                //create a layer for EVERY SINGLE layer in the actual tile map
                //i created two tile layers, the background layer and the solid layer
                //background layer is just the background, the solid layer are tiles that the player collides with
                //its important to have them seperate
                //though its not required
                
                //backround layer
                //the argument to the createLayer function is the name of the layer set by the Tiled level editor
                //the data for this layer can be viewed in the levle editor, or you can look at the map.json file
                this.background = this.map.createLayer('Background');
                this.solid = this.map.createLayer('solid');
                
                //the default game world size is the same as the canvas size
                //however we want the plaeyr ot be able to move around the entire world
                //so we must set the size of the gameworld to the size of the tilemap, that way the game world isn't too big or small
                this.background.resizeWorld();
                
                //phaser doesn't actually know anything about tile layers and collision, it just creates drawable tiles
                //now we need to specify that the tiles in the solid layer should actually collide with stuff
                //the first two arguments give a range of tile IDs that you want to set collision info to
                //the third argument sets whether or not the tile should collide
                //the last argument is the layer that you want to get tiles from
                this.map.setCollisionBetween(1, 10000, true, 'solid');
            },
            
            create: function() {
                
                //misc instructions, ignore
                document.getElementById("additional").innerHTML = "Use the arrow keys to move the player. Press Enter to enter battle";
        		
                //Phaser draws objects in the order they are created (all applications have a rendering order, this is jsut phaser's order)
                //this means that objects created first will be drawn underneath objects created last
                //so we need to create background objects first
                
                //first we will create the tile map
                this.generateTilemap();
                
                //now we create the player
                //we already created a player sprite, but we told phaser not to draw him
                //we need to add him back to the game world for drawing
                game.add.existing(player.sprite);
                
                //we also want he camera to follow the player
                game.camera.follow(player.sprite);
                
                //this function makes phaser use arrow keys for movement
                //it creates a collection of keys that you can poll for events (look at update function for polling code)
                //polling a key means you check if a key is pressed, or released
                this.cursors = game.input.keyboard.createCursorKeys();
                player.cursors = this.cursors;
                player.x = 0;
                
                //make phaser use a call back listener
                //listener functions are functions that are called whenever a certain action happens
                //here we want phaser to call a special function everytime a key is pressed down
                //first argument is the context where the call back functiosn are run
                //basically its what the name of the object that the 'this' variable in the listener function refers to
                //second argument is the function to call when a key is pressed
                //there are two more arguments that i haven't used yet
                game.input.keyboard.addCallbacks(this, this.handleKeyDown);
            },
            
            //update function is where the game world is updated
            //here we need to handle input, update physics, and handle collision
            //phaser does the physics and collision for us, we jst need to specify what collides
            update: function() {
                
                //NORMALLY we do input handling before all physics and collision
                //but phaser saves some data in the collision handling that we sometimes need in the input handling
                //so when working with phaser, we will do collision handling first
                
                //this funciton tells phaser to collide two objects, or two groups of objects
                //i haven't created a group of objects explicitly, but the tile map layer is a group of objects generated by phaser
                //this is why we need a seperate layer for background and solid, i only want my player to collide with fenses or houses
                //not the grass
                game.physics.arcade.collide(player.sprite, this.solid);
                
                //next handle all the game's inputs
                //start with keystate inputs, explained in the keystate function
                //we don't have to worry about button press events since we created listener for those events
                //but we can't create a listener for state events
                this.handleStateInputs();
                
                //now we want to see if the player randomly encountered an enemy, this will send us to the battle state
                //we only want to check if player encounterd an enemy if he moved
                //for now its commentd out since I didn't create the battle state
                //basically if hte player travels a certain distance, we check if he should battle an enemy
                /*if(player.sprite.body.deltaABSX() >= THRESHOLD || player.sprite.body.deltaABSY() >= THRESHOLD) {
                    
                    game.state.start('battle');
                }*/
            },
            
            handleStateInputs: function() {
                
                //input handling for player is done in this function
                //it might seem weird to have a function that jus calls another function
                //but this is a good way to organize your code for each section of the game.
                //we need to have a seperate section for input handling, so this function will contain all the code for input handling
                //but input handling can be broken down into different components, so each component will have its own input handling function
                this.handlePlayerKeystates();
                
                //after we can handle other key states, if there are any
            },
            
            handlePlayerKeystates: function() {
                
                //first we make player move and animate according to where he is moving
                //isDown is a bool value, that is true if the key is pressed down, and false otherwise
                //Checking if a key is pressed down or not is called checking a key state
                //Keystates only tell you if a button is pressed or not, 
                //it DOESN'T LET YOU HANDLE KEY PRESS EVENTS
                //this means if you want the player to attack when they press the attack button
                //if you check for keystate the game will make the player attack non stop, because you're not checking if the player pressed the attack button
                //you're only checking if the button is presed down
                //this might be confusing, but it'll make more sense with practice
                
                //for now disable diagnoal movement since i have no animation for diagnoal movement
                if((this.cursors.left.isDown || this.cursors.right.isDown) && (this.cursors.up.isDown || this.cursors.down.isDown)) {
                    
                    return;
                }
                
                if(this.cursors.left.isDown) {
                
                    //move left, the sprite has a variable called body
                    //this variable is a physics object that represents the object in the physics engine
                    //by setting its velocity we can make it move
                    player.sprite.body.velocity.x = -200;
                    
                    //run an animation, we created this animation already
                    player.sprite.animations.play('left');
                    
                } else if(this.cursors.right.isDown) {
                    
                    player.sprite.body.velocity.x = 200;
                    player.sprite.animations.play('right');
                    
                } else {
                    
                    //player isn't moving left or right, we have to set his velocity to 0 since the physcis engine isn't going to know when to stop moving
                    player.sprite.body.velocity.x = 0;
                    
                    //only stop animation if the player is moving left or right
                    //this is important because we don't want to stop animation when the player is moving up or down
                    //because the player will never animate then
                    if(player.sprite.animations.name == 'left' || player.sprite.animations.name == 'right') {
                        
                        //we stop the animation
                        //the first argument is the name of the animtion yo uwant to stop
                        //by setting to null, we stop the current animation
                        //second argument tells phaser we want to stop the animation and start drawing the first frame of the animation
                        //this way if player is standing still, he will face left or right, adn we won't have to determine which way he is facing
                        player.sprite.animations.stop(null, true);
                    }
                }
                
                if(this.cursors.up.isDown) {
                    
                    //IMPORTANT: IN COMPUTER GRAPHICS, THE POSTIIVE Y AXIS GOES DOWN, THE NEGATIVE Y AXIS GOES UP
                    //THIS MEANS THAT UPWARDS IS NEGATIVE
                    player.sprite.body.velocity.y = -200;
                    player.sprite.animations.play('up');
                    
                } else if(this.cursors.down.isDown) {
                    
                    player.sprite.body.velocity.y = 200;
                    player.sprite.animations.play('down');
                    
                } else {
                    
                    player.sprite.body.velocity.y = 0;
                    
                    if(player.sprite.animations.name == "up" || player.sprite.animations.name == 'down') {
                        
                        player.sprite.animations.stop(null, true);
                    }
                }
            },
            
            //function that we will send to phaser to handle key press events
            handleKeyDown: function(key) {
                
                //if user presses the enter key we will enter the battle state
                if(key.keyCode == Phaser.Keyboard.ENTER) {
                    
                    game.state.start('battle');
                }
            },
            
            
            //this function is called when we leave the currents tate
            //the battle state is a seperate state, and when we enter the battle state, this state will be destoryed
            //when this state is destoryed, all objects in this state will also be destoryed, hence the player is destoryed
            //we want to prevent that
            shutdown: function() {
                
                game.world.remove(player.sprite);
            },
        };
        
        //creates a text box at the given position
        //returns a Phaser Graphics object that represents the text box
        function createTextBox(x, y, width, height) {
            
            var box = game.add.graphics(x, y);
            
            //first create the colored rectangle
            var fillColor = 0x000099;
            box.beginFill(fillColor, 0.4);
            box.drawRect(0, 0, width, height);
            box.endFill();
            
            //now create a border around it to make it look nice
            var lineThickness = 3;
            var lineColor = 0x888888;
            
            box.lineStyle(lineThickness, lineColor, 0.8);
            box.x = x + lineThickness / 2;
            box.lineTo(width - lineThickness, 0);
            box.lineTo(width - lineThickness, height - lineThickness);
            box.lineTo(0, height - lineThickness);
            box.lineTo(0, 0);
            
            return box;
        }
        
        //the battle state
        //here players will battle some number of monsters
        var battleState = {
            
            //load the data of the monsters the player has to fight
            loadMonsters: function() {
                
                //here is where the monsters list we loaded previously, and the mosnter database come into play
                //we want to randomly generate a mosnter, so we will randomly select the name of a mosnter that can spawn in this map
                //generate the array of mosnter names
                //the getJSON function uses a key to a previously loaded json file
                //it then returns a java script object containing the data loaded in the file
                //please look up how JSON works if you are unfamiliar with it
                var monsterNames = game.cache.getJSON('monsterList');
                
                //now we want to randomly select a monster name from this list
                //the object basiclaly has 1 element named monsters, which is an array of names
                //these names are actually keys to the database, so we can use it directly
                //randomly select monster name (for now just use the orc name since i haven't created the others)
                var id = 0;
                var monsterName = monsterNames.monsters[id];
                
                //now we can use this key to load the monster data
                //first turn the monster database to a javascript object
                var monsterDatabase = game.cache.getJSON('monsterData');
                
                //now get the monster with the above key
                //if you don't understand this notation, please search up javascript objects: http://www.w3schools.com/js/js_object_definition.asp, and follow the next 3 tutorials
                var monster = new rpgEntity();
                $.extend(monster, monsterDatabase[monsterName]);
                monster.x = 200;
                monster.y = 300;
                
                return [monster];
            },
            
            generateMonsterSprites: function(monsters) {
                
                //all monsters have a key that can be used to get the name of the sprite for the monster
                //lets get this monsters image to draw
                //we can position the mosnter for battle as well
                var i = 0;
                for(i = 0; i < monsters.length; ++i) {
                    
                    monsters[i].sprite = game.add.sprite(monsters[i].x, monsters[i].y, monsters[i].imageKey);
                }
            },
            
            //saves the orientation of the player as it was in the overworld state, before the battle started
            //this is needed so we can restore the player back to his original position when the battle ends
            savePlayerOverworldOrientation: function() {
                
                this.playerPositionX = player.sprite.x;
                this.playerPositionY = player.sprite.y;
                this.playerAnimation = player.sprite.animations.name;
            },
            
            //loads the players overworld position so that he ends up exactly where he was before the battle started
            loadPlayerOverworldOrientation: function() {
                
                player.sprite.x = this.playerPositionX;
                player.sprite.y = this.playerPositionY;
                player.sprite.animations.play(this.playerAnimation);
                player.sprite.animations.stop(null, true);
            },
            
            //positions the player in the battle screen
            orientPlayerForBattle: function() {
                
                player.sprite.x = 500;
                player.sprite.y = 300;
                
                player.sprite.body.velocity.x = 0;
                player.sprite.body.velocity.y = 0;
                
                //player face left
                player.sprite.animations.play('left');
                player.sprite.animations.stop(null, true);
            },
            
            //an action box is a rectangular display that lists a bunch of possible actions a player can make
            //it consists of a container that stores the text, and the texts that are supposed to be displayed
            //it also contains information about what action is currently being selected, and a way to indicate what action is selected
            createActionBox: function(x, y, width, height, choices) {
                
                var box = new Object();
                
                this.createActionsContainer(x, y, width, height, box);
                this.createActionTexts(choices, box);
                
                //players selected action
                box.selectedAction = 0;
                
                //now i'll create a rectangle that will circle the option the player selects
                //the constructor for graphics takes in a position, but the position actually sets the origin for hte graphics obejct
                //any draw positions will be relative to this origin, so set it to 0, 0
                box.selectionOutline = game.add.graphics(0, 0);
                box.actionsContainer.addChild(box.selectionOutline);
                
                return box;
            },
            
            //actions container is the rectangle box where the action texts are displayed
            createActionsContainer: function(x, y, width, height, actionBox) {
                
                var actionBoxX = 0;
                var actionBoxY = game.scale.height - height;
                
                actionBox.actionsContainer = createTextBox(x, y, width, height);
            },
            
            //the actions available to the player, in text form
            createActionTexts: function(choices, actionBox) {
                
                var textMargins = 10;
                var textSize = 28;
                actionBox.heightLargestText = 0;
                
                var actionTexts = [];
                
                var i = 0;
                for(i = 0; i < choices.length; ++i) {
                    
                    actionTexts.push(game.add.text(textMargins, textMargins + i * textSize, choices[i], {fill: '#fff'} ));
                
                    actionBox.heightLargestText = actionTexts[i].height > actionBox.heightLargestText ? actionTexts[i].height : actionBox.heightLargestText;
                    
                    //by setting this text to the child of the action box, the text will be positioned relative to the action box instead of relative to the screen
                    actionBox.actionsContainer.addChild(actionTexts[i]);
                }
                
                actionBox.texts = actionTexts;
            },
            
            //the actionBox will have a selected text that needs to be highlighted, and this function positions the highlight so that it's surroundign the selected text
            highlightSelectedAction: function(actionBox) {
                
                //first clear the previously drawn rectangle
                actionBox.selectionOutline.clear();
                
                //clear resets line style, so set it again
                actionBox.selectionOutline.lineStyle(2, 0x0000FF, 1);
                
                //now draw a new rectangle around the current selection
                var xPosition = actionBox.texts[actionBox.selectedAction].x;
                var yPosition = actionBox.texts[actionBox.selectedAction].y;
                
                var height = actionBox.heightLargetText;
                
                actionBox.selectionOutline.drawRect(xPosition, yPosition, 80, 30);
            },
            
            //draws a rectangle around the monster that the player has currently chosen to attack
            highlightSelectedEnemy: function() {
                
                //first clear the previously drawn selection
                this.selectedMonsterIndicator.clear();
                
                //set line style
                this.selectedMonsterIndicator.lineStyle(2, 0xff0000, 1);
                
                //make sure the selected mosnter exists
                this.selectedMonsterId = clamp(this.selectedMonsterId, 0, this.monsters.length);
                
                var xPosition = this.monsters[this.selectedMonsterId].sprite.x;
                var yPosition = this.monsters[this.selectedMonsterId].sprite.y;
                var width = this.monsters[this.selectedMonsterId].sprite.width;
                var height = this.monsters[this.selectedMonsterId].sprite.height;
                
                this.selectedMonsterIndicator.drawRect(xPosition, yPosition, width, height);
            },
            
            //function that is called when the player's attack animation finishes
            //this function should transition to the next game state, and apply damage to enemies as needed
            finishPlayerAttack: function() {
                
                this.changeState(this.BattleState.PLAYER_ATTACK_RESULTS);
            },
            
            //this function clears all data required for all the states, used when you first enter battle
            clearStates: function() {
                
                for(state in this.BattleState) {
                    
                    this.exitState(this.BattleState[state]);
                }
            },
            
            //this function makes it easy to handle state changes
            //it goes from one state to another, and changes any variables required when entering or leaving a state
            changeState: function(targetState) {
                
                this.exitState(this.currentState);
                this.enterState(targetState);
            },
            
            //this function handles all variable changes that need to be made when you exit the given state
            //it calls any functions that need to be called when a state finishes
            exitState: function(stateToExit) {
                
                if(stateToExit == this.BattleState.PLAYER_SELECT_MAIN_ACTION) {
                    
                    this.actionBox.selectionOutline.visible = false;
                }
                
                if(stateToExit == this.BattleState.PLAYER_SELECT_FIGHT_ACTION) {
                    
                    this.fightBox.actionsContainer.visible = false;
                }
                
                if(stateToExit == this.BattleState.PLAYER_SELECT_ATTACK_TARGET) {
                    
                    this.selectedMonsterIndicator.visible = false;
                    this.textBox.visible = false;
                }
                
                if(stateToExit == this.BattleState.PLAYER_ATTACKING) {
                    
                    this.textBox.visible = false;
                }
                
                if(stateToExit == this.BattleState.PLAYER_ATTACK_RESULTS) {
                    
                    //delete all damage texts, and to do that we have to delete all phaser sprites
                    this.clearDamageTexts();
                }
            },
            
            //this function handles all variable changes that need to be made when you enter a given state
            //it calls any functions that need to be called when a state starts
            enterState: function(stateToEnter) {
                
                if(stateToEnter == this.BattleState.PLAYER_SELECT_MAIN_ACTION) {
                    
                    this.actionBox.selectedAction = 0;
                    this.actionBox.selectionOutline.visible= true;
                }
                
                if(stateToEnter == this.BattleState.PLAYER_SELECT_FIGHT_ACTION) {
                    
                    this.fightBox.selectedAction = 0;
                    this.fightBox.actionsContainer.visible = true;
                }
                
                if(stateToEnter == this.BattleState.PLAYER_SELECT_ATTACK_TARGET) {
                    
                    this.selectedMonsterId = 0;
                    this.selectedMonsterIndicator.visible = true;
                    this.textBox.visible = true;
                    this.text.setText("Select a monster to attack.");
                }
                
                if(stateToEnter == this.BattleState.PLAYER_ATTACKING) {
                    
                    this.textBox.visible = true;
                    this.text.setText("Attacking " + this.monsters[this.selectedMonsterId].imageKey);
                    player.sprite.animations.play("attack");
                    
                    //set the player's attack attribute
                    player.lastUsedAttack.power = player.strength;
                }
                
                if(stateToEnter == this.BattleState.PLAYER_ATTACK_RESULTS) {
                    
                    //player just attacked a mosnter, determine the results of the attack, and display it to the screen
                    var damage = this.determineAttackResults(player, this.monsters[this.selectedMonsterId]);
                    
                    //get damage received by this entity
                    this.damageTexts.push(this.createDamageText(this.monsters[this.selectedMonsterId], damage) );
                }
                
                if(stateToEnter == this.BattleState.ENEMY_TURN_START) {
                    
                    this.currentEnemy = 0;
                }
            
                this.currentState = stateToEnter;
            },
            
            //makes the attacker attack the defender
            //determines if the attack hit the defender
            //determines damage dealt
            //returns a string
            determineAttackResults: function(attacker, defender) {
                
                var damage = determineDamage(attacker.lastUsedAttack.power, defender.defense);
                defender.getHit(damage);
                return damage;
            },
            
            //creates a damage text that displays the amount of damage the given entity received
            createDamageText: function(entity, damageReceived) {
                
                var damageText = new Object();
                damageText.text = game.add.text(entity.sprite.width / 2, 0, damageReceived.toString(), {fill: 'red'});
                damageText.text.alpha = 0.3;
                damageText.text.anchor.setTo(0.5, 0);
                
                entity.sprite.addChild(damageText.text);
                
                var textTween = game.add.tween(damageText.text).to({y: -40, alpha: 1}, 1000, Phaser.Easing.Bounce.Out);
                textTween.start();
                
                damageText.tween = textTween;
                
                return damageText;
            },
            
            clearDamageTexts: function() {
                
                var i = 0;
                
                for(i = 0; i < this.damageTexts.length; i++) {
                    
                    this.damageTexts[i].text.destroy();
                }
                
                this.damageTexts = [];
            },
            
            //checks if all of the attack results texts have finished their tweening
            finishedDisplayingResults: function() {
                
                //if any text is still tweening, then we have to wait for it to finish
                var i = 0;
                
                for(i = 0; i < this.damageTexts.length; i++) {
                    
                    
                    if(this.damageTexts[i].tween.isRunning) {
                        
                        return false;
                    }
                    
                }

                return true;
            },
            
            create: function() {
                
                //misc instructions, ignore
                document.getElementById("additional").innerHTML = "select an action";
                
                var style = { font: "bold 32px Arial", fill: "#fff", boundsAlignH: "center", boundsAlignV: "middle"};
        		this.text = game.add.text(0, 0, "BATTLe", style);
        		
                //first we have to create a background to display
                //i haven't put in any background yet but just know that it has to be created first
                
                //next we will create a monster
                //we might have a battle with multiple monsters, so the name is plural
                //although right now it generates a single monster, later it might create an array of monsters
                this.monsters = this.loadMonsters();
                
                //we've only loaded the data for the mosnter, we now need to create an image so we can see them
                this.generateMonsterSprites(this.monsters);
                
                //now we want to reload the player
                game.add.existing(player.sprite);
                
                //we also have to reposition the player since we are starting a battle
                //when we exit the battle, the player will be at a different position than when he started, so we need to save the players old position and orientation
                this.savePlayerOverworldOrientation();
                
                //set player to battle position, and orientation
                this.orientPlayerForBattle();
                
                //now we want to have some UI to display all the battle options
                
                //first we have to create the box where the UI is displayed
                //if you look at final fantasy battles, there are blue rectangles that contain all the text
                //first is the rectangle that contains all the actions the player can take
                
                var actionBoxWidth = game.scale.width;
                var actionBoxHeight = 130;
                
                //create the main actions
                this.actionBox = this.createActionBox(0, game.scale.height - actionBoxHeight, actionBoxWidth, actionBoxHeight, ['fight', 'items', 'run']);
                
                //create the options that show up if player selects to fight
                this.fightBox = this.createActionBox(game.scale.width / 3, game.scale.height - actionBoxHeight - 20, game.scale.width / 3, actionBoxHeight, ['attack', 'skills', 'cancel']);
                this.fightBox.actionsContainer.visible = false;
                
                //again we want to add a listener for when the player presses on keys
                game.input.keyboard.callbackContext = this;
                game.input.keyboard.onDownCallback = this.onKeyDown;
                
                //variables that represent the current battle state
                //this emulates a game state system, but without having to switch between phaser game states
                this.BattleState = {
                    
                    PLAYER_SELECT_MAIN_ACTION: 0,
                    PLAYER_SELECT_FIGHT_ACTION: 1,
                    PLAYER_SELECT_ATTACK_TARGET: 2,
                    PLAYER_ATTACKING: 3,
                    PLAYER_ATTACK_RESULTS: 4,
                    ENEMY_TURN_START: 5,
                };
                
                this.currentState = this.BattleState.PLAYER_SELECT_MAIN_ACTION;
                
                //add a function to call when the player's aniamtion finishes, because we don't want damage calculation to occur while the player's animation is ongoing
                player.sprite.events.onAnimationComplete.add(this.finishPlayerAttack, this);
                
                //when the player starts to attack we need a way for the player to select a mosnter to attack
                //this variable keeps track of what mosnter the player has selected
                this.selectedMonsterId = 0;
                
                //this graphics object will draw a rectangle around the selected mosnter
                this.selectedMonsterIndicator = game.add.graphics(0, 0);
                
                //we need a way to give messages to the player
                //we will create a text box at the top of the screen, it will only be visible when there is a message for the player to read
                this.textBox = createTextBox(0, 0, game.scale.width, 50);
                
                //now create a text that will be displayed
                //these settings make the text centerd to the message box
                this.text = game.add.text(0, 0, "Message");
                this.text.x = this.textBox.width / 2;
                this.text.anchor.x = 0.5;
                this.text.fill = 'white';
                this.textBox.addChild(this.text);
                
                //this contains text that will display the amount of damage an enemy or player received after an attack
                //new text is added to it whenever an entity is damaged, and once the text finishes displaying, it will be deleted
                //damage texts will contain the text reprsenting the damage, and a phaser tween object
                //tween objects represent a linear interpolation between two object states, we will use it to animate the text
                this.damageTexts = [];
                
                /*create some kind of indicator to indicate what mosnter hte player has currently selected
                create a number that represents the currently selected mosnter's array index
                create a graphics object that will draw a rectangle around the currently selected monster
                
                when player presses attack button:
                
                set the marker to the first object in the list
                begin drawing the rectangle
                allow user's up/down movement to select a different mosnter in the list
                move the rectangle according to the users selection
                if the player presses enter, then set the target to that monster, and set the current state to player attacking
                stop drawing the selection, but the selected monster's id will be saved
                
                once player presses the attack button, it will run the player attack animtion.
                after the animation is compelted it should display the damage the enemy received over their head
                the next turn won't start until the damage is disappeard on all enemies that were hit
                after the damage dissapears, it will be the enemies turn.*/
                
                this.clearStates();
                this.changeState(this.BattleState.PLAYER_SELECT_MAIN_ACTION);
            },
            
            update: function() {
            
                //make the game highlight the player's current selected action
                this.highlightSelectedAction(this.actionBox);
                this.highlightSelectedAction(this.fightBox);
                
                this.highlightSelectedEnemy();
                
                //if we are showing player attack results, then we have to check if all the damage numbers have been displayed
                //if we've displayed all the numbers, its time to move onto the enemy's turn
                if(this.currentState == this.BattleState.PLAYER_ATTACK_RESULTS) {
                    
                    var moveToNextState = this.finishedDisplayingResults();
                    
                    if(moveToNextState) {
                        
                        this.changeState(this.BattleState.ENEMY_TURN_START);
                    }
                }
            },
            
            onKeyDown: function(key) {
                
                this.handlePlayerInput(key);
            },
            
            handlePlayerInput: function(key) {
                
                //certain game states only allow certain inputs
                //main game state allows users to select fight, items, or run
                //fight action state allows users to choose to attack, use a skill, or other stuff
                if(this.currentState == this.BattleState.PLAYER_SELECT_MAIN_ACTION) {
                    
                    this.handleMainActionInput(key);
                    
                } else if(this.currentState == this.BattleState.PLAYER_SELECT_FIGHT_ACTION) {
                    
                    this.handleFightActionInput(key);
                    
                } else if(this.currentState == this.BattleState.PLAYER_SELECT_ATTACK_TARGET) {
                    
                    this.handleTargetSelectionInput(key);
                }
            },
            
            handleMainActionInput: function(key) {
                
                //first handle user input if they press up or down to choose an action
                this.handleActionSelection(key, this.actionBox);
                
                //execute the action the user has chosen
                if(key.keyCode == Phaser.Keyboard.ENTER) {
                    
                    //we would like to return to the main map if player selected run
                    if(this.actionBox.texts[this.actionBox.selectedAction].text == "run") {
                        
                        game.state.start('overworld');
                    }
                    
                    if(this.actionBox.texts[this.actionBox.selectedAction].text == "fight") {
                        
                        this.changeState(this.BattleState.PLAYER_SELECT_FIGHT_ACTION);
                    }
                }
            },
            
            handleFightActionInput: function(key) {
                
                this.handleActionSelection(key, this.fightBox);
                
                if(key.keyCode == Phaser.Keyboard.ENTER) {
                    
                    //we would like to return to the main map if player selected run
                    if(this.fightBox.texts[this.fightBox.selectedAction].text == "cancel") {
                        
                        this.changeState(this.BattleState.PLAYER_SELECT_MAIN_ACTION);
                    }
                    
                    if(this.fightBox.texts[this.fightBox.selectedAction].text == "attack") {
                        
                        this.changeState(this.BattleState.PLAYER_SELECT_ATTACK_TARGET);
                    }
                }
            },
            
            handleTargetSelectionInput: function(key) {
                
                if(key.keyCode == Phaser.Keyboard.UP) {
                    
                    this.selectedMonsterId -= 1;
                    
                    if(this.selectedMonsterId < 0) {
                        
                        this.selectedMonsterId = this.monsters.length - 1;
                    }
                }
                
                if(key.keyCode == Phaser.Keyboard.DOWN) {
                    
                    this.selectedMonsterId = (this.selectedMonsterId + 1) % this.monsters.length;
                }
                
                if(key.keyCode == Phaser.Keyboard.ENTER) {
                    
                    this.changeState(this.BattleState.PLAYER_ATTACKING);
                }
            },
            
            handleActionSelection: function(key, actionBox) {
                
                //move the players selection
                if(key.keyCode == Phaser.Keyboard.UP) {
                    
                    actionBox.selectedAction -= 1;
                    
                    if(actionBox.selectedAction < 0) {
                        
                        actionBox.selectedAction = actionBox.texts.length - 1;
                    }
                }
                
                if(key.keyCode == Phaser.Keyboard.DOWN) {
                    
                    actionBox.selectedAction = (actionBox.selectedAction + 1) % actionBox.texts.length;
                }
            },
            
            //this is a render (drawing) function
            //phaser draws all of our game objects automatically, however we might want to do our own rendering calls
            //in the render function we dont do any calculations at all
            //all math, physics, updating, should be done in the update function
            //only draw calls should be placed in this function
            render: function() {
                
                //i want to draw the selection box as a rectangle, since phaser doesn't do it automatically
                //we need to postiion the rectangle around the current selection, but in the render function we only draw, no calculations should be done here
            },
            
            shutdown: function() {
                
                //now we also want the player ot return to whatever he was doing, so set him back to his original position
                this.loadPlayerOverworldOrientation();
                
                //once again we don't want the game to destroy the player
                game.world.remove(player.sprite);
            },
        };
        
        //register all of the gameplay states
        game.state.add('boot', bootState);
        game.state.add('load', loadState);
        game.state.add('overworld', overworldState);
        game.state.add('battle', battleState);
        
        //now run the boot state, which will call load and overworld as needed
        game.state.start('boot');
        
        
    </script>
</div>