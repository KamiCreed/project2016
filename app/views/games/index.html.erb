<h1 id="asdf">This is where the game will go</h1>
<p id="additional" style="font-size: 20px; color: red; text-align: center">  </p>

<!-- Style the game display canvas however you wish by syling the 'Game' id -->
<div id="Game" style="padding: 10px;">
    
    <script>
        
        //create instance of the game engine.
        //This creates the canvas for the game to display, and allows you to use the Phaser engine
        var game = new Phaser.Game(800, 600, Phaser.AUTO, 'Game');
        
        //Returns a random integer between min (inclusive) and max (inclusive)
        function getRandomInt(min, max) {
            
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        function clamp(number, min, max) {
            
            return Math.max(min, Math.min(number, max));
        }
        
        //given an attacker's power attribute, and a defender's defense attribute, this function will calculate the damage received by teh defender
        //attackPower is a number, and you can use any entity attribute to represent the power
        //for example, a normal attack might use an etities strength, while a magic attack might use their magic power
        //same applies for the defender
        //this is a general use function meant to calcualte damage for any time of object
        //this can be extended to incorporate a damage range so it can calculate a random damage
        function determineDamage(attackPower, defenderDefense) {
            
            return Math.floor(clamp(attackPower - defenderDefense / 2, 1, attackPower));
        }
        
        function rpgEntity() {
            
            this.health = 20;
            this.strength = 10;
            this.defense = 10;
            this.level = 1;
            this.name = "Player";
            this.shouldDelete = false;
            
            //last used attack is the attribtues of the attack last used by this entity
            //this is used to save data about an attack, which is used for damage calculation during the damage calculation state
            this.lastUsedAttack = {
                
                //must set this whenever the entity attacks
                //feel free to add other traits at any time
                power: 10,
            };
        };
        
        rpgEntity.prototype.getHit = function(damageReceived) {
            
            this.health = clamp(this.health - damageReceived, 0, this.health);
        };
        
        function mark() {
            
            this.shouldDelete = true;
        }
        
        //makes enemy start their death animation, sets the call back function
        function killEntity(dyingEntity) {
            
            //start death animation, make entity fade to black as well
            //when it finishes fading, it will be marked for deletion
            tween = game.add.tween(dyingEntity.sprite).to({alpha: 0});
            tween.onComplete.add(mark, dyingEntity);
            tween.delay(600);
            tween.start();
            dyingEntity.sprite.animations.play("dying");
        };
        
        //define a global player variable
        //players will be global since Phaser deletes objects after a game state has ended (see below for explanation of game state)
        //We don't want to have to recreate a player object every single time we end a battle, so we will make a global player
        var player = new rpgEntity();//{
            
            //players will have various stats, these will be loaded from the rails data base
            //for now all we have is the player's sprite, which is a phaser game object that handles drawing/movement, and other great stuff
            //we don't actually need to put this since we can add it later
            //sprite: 0,
            
            //we will also have other stats about the player, read for the data base. uncomment later as needed
            /*
            anything with @player should be embeded ruby, right now leave it unembed
            
            this.level = @player.level
            this.health = ...
            ...
            ...
            */
        //};
        
        //object that handles Phaser sprite highlighting
        //it takes a list of phaser objects, and draws a border around a subset of objects in that list
        //it then keeps a list of highlights, and can clear them and recreate them as needed
        function objectHighlighter() {
            
            //each object will in the array has two properties
            //the first property is the object that will be hightlighted
            //the second property is the phaser graphics object that does the highlighting
            //ex: highlights[0] = {object: someOrc, graphics: someGraphicsObject}
            this.highlights = [];
        };
        
        //takes the given PHASER GRAPHICS OBJECT and highlights it
        //this object must be a phaser object that has the variables, x, y, width, and height
        //and supports the function addchild()
        objectHighlighter.prototype.addHighlight = function(objectToHighlight) {
            
            var highlightedObject = {};
            highlightedObject.object = objectToHighlight;
            
            //create the graphics object
            highlightedObject.graphics = game.add.graphics(0, 0);
            highlightedObject.object.addChild(highlightedObject.graphics);
            
            //style the highlight
            highlightedObject.graphics.lineStyle(2, 0xff0000, 1);
            
            //draw the highlight
            var x = objectToHighlight.x;
            var y = objectToHighlight.y;
            var width = objectToHighlight.width;
            var height = objectToHighlight.height;
            
            highlightedObject.drawRect(x, y, width, height);
            
            this.highlight.push(highlightedObject);
        };
        
        objectHighlighter.prototype.clearHighlights = function() {
            
            for(var i = 0; i < this.highlights.length; ++i) {
                
                this.highlights[i].graphics.destroy();
            }
            
            this.highlights = [];
        };
        
        //an action display is a rectangular display that lists a bunch of possible actions a player can make
        //it consists of a container that stores the text, and the texts that are supposed to be displayed
        //it also contains information about what action is currently being selected, and a way to indicate what action is selected
        function actionDisplay(x, y, width, height, actionTexts) {
            
            //background that is displayed behind all the text
            this.background = createActionDisplayBackground(x, y, width, height);
            
            //index of currently selected action (corresponds to the array of action texts)
            this.selectedAction = 0;
            
            //object that indicates what action is currently being selected
            //the constructor for graphics takes in a position, but the position actually sets the origin for hte graphics obejct
            //any draw positions will be relative to this origin, so set it to 0, 0
            this.selectionDisplay = game.add.graphics(0, 0);
            this.background.addChild(this.selectionDisplay);
            
            //the text that will be displayed
            this.actionTexts = createActionTexts(actionTexts, this.background);
        };
        
        //the actionBox will have a selected text that needs to be highlighted, and this function positions the highlight so that it's surroundign the selected text
        actionDisplay.prototype.highlightSelectedAction = function() {
            
            //first clear the previously drawn rectangle
            this.selectionDisplay.clear();
            
            //don't draw anything if there is no text
            if(this.selectedAction >= this.actionTexts.length) {
                
                return;
            }
            
            //clear resets line style, so set it again
            this.selectionDisplay.lineStyle(2, 0x0000FF, 1);
            
            //now draw a new rectangle around the current selection
            var xPosition = this.actionTexts[this.selectedAction].x;
            var yPosition = this.actionTexts[this.selectedAction].y;
            
            this.selectionDisplay.drawRect(xPosition, yPosition, 80, 30);
        };
        
        //users will be able to change their currently selected action
        actionDisplay.prototype.selectNext = function() {
            
            this.selectedAction = (this.selectedAction + 1) % this.actionTexts.length;
        };
        
        actionDisplay.prototype.selectPrevious = function() {
            
            this.selectedAction = this.selectedAction - 1 < 0 ? this.actionTexts.length - 1 : this.selectedAction - 1;
        };
        
        //the display background is the rectangle box where the action texts are displayed
        function createActionDisplayBackground(x, y, width, height) {
            
            var actionBoxX = 0;
            var actionBoxY = game.scale.height - height;
            
            return createTextBox(x, y, width, height);
        };
        
        //the actions available to the player, in text form
        function createActionTexts(choices, actionDisplayBackground) {
            
            var textMargins = 10;
            var textSize = 28;
            
            var actionTexts = [];
            
            var i = 0;
            for(i = 0; i < choices.length; ++i) {
                
                actionTexts.push(game.add.text(textMargins, textMargins + i * textSize, choices[i], {fill: '#fff'} ));
        
                //by setting this text to the child of the action box, the text will be positioned relative to the action box instead of relative to the screen
                actionDisplayBackground.addChild(actionTexts[i]);
            }
            
            return actionTexts;
        };
        
        //onKeyDown listener for action Display objects
        //this will assume the arrow keys is used to move, and it will move the current action selection for the given action display
        function actionDisplayKeyDown(key, actionDisplay) {
                
            //move the players selection
            if(key.keyCode == Phaser.Keyboard.UP) {
                
                actionDisplay.selectPrevious();
            }
            
            if(key.keyCode == Phaser.Keyboard.DOWN) {
                
                actionDisplay.selectNext();
            }
        };
        
        //a substate object that handles functionality during a state
        //its pretty much just a container for different functions that are called during certain game states
        //it also stores the context under which the given functions should be called
        function subState() {
            
            
        };
        
        //adds a function of the given name to the state
        //look at the state manager function calls to figure out what names to use
        //generally it should be named on'Action'
        subState.prototype.addFunction = function(functionName, functionImplementation, contextToCall) {
            
            //adds the given function as an object to the state
            //the object has two properties, the actual function, and the context to call the function in
            this[functionName] = {func: functionImplementation, context: contextToCall};
        };
        
        //a sub state system that can be used at each major game state
        //ignore for now if you don't know what a game state is, and read below
        function stateManager() {
            
            //associative array of states
            this.states = {};
            this.currentState = "";
        };
        
        //adds the given state to the state manager
        //state name is the name used to identify the state (key to a hash)
        //state is the state object
        stateManager.prototype.addState = function(stateName, state) {
            
            this.states[stateName] = state;
        };
        
        //calls the exit function of all of the states
        //its a good idea to call this once all the states have been created
        stateManager.prototype.exitAll = function() {
            
            for(current in this.states) {
                
                if(typeof this.states[current] !== "undefined") {
                    
                    this.states[current].onExit.func.call(this.states[current].onExit.context);
                }
            }
        };
        
        //switch from one state to another, this will exit current state, and switch to given state
        //targetStateName is the name of the state you want to change to
        //undefine behaviour if the target state hasn't been created
        stateManager.prototype.changeState = function(targetStateName) {
            
            //first exit the current state
            if(this.currentState != "" && typeof this.states[this.currentState].onExit !== "undefined") {
                
                this.states[this.currentState].onExit.func.call(this.states[this.currentState].onExit.context);
            }
            this.currentState = targetStateName;
            
            if(typeof this.states[this.currentState].onEnter !== "undefined") {
                
                this.states[targetStateName].onEnter.func.call(this.states[targetStateName].onEnter.context);
            }
            
        };
        
        //calls the update function of the current state
        stateManager.prototype.onUpdate = function() {
            
            if(typeof this.states[this.currentState].onUpdate !== "undefined") {
                
                this.states[this.currentState].onUpdate.func.call(this.states[this.currentState].onUpdate.context);
            }
        };
        
        stateManager.prototype.onKeyDown = function(key) {
            
            if(typeof this.states[this.currentState].onKeyDown !== "undefined") {
                
                this.states[this.currentState].onKeyDown.func.call(this.states[this.currentState].onKeyDown.context, key);
            }
        };
        
        function asdf(key) {
            
            document.getElementById("additional").innerHTML = this.monsters[key].health;
        };
        
        //create all of the required game states
        //A game state is basically a collection of all of the objects that are currently on screen
        //It also includes all the available functionality at any given time
        //for example, games can have a menu state, here the users can click on different buttons to go to different screens
        //it can have a gameplay state, where the actual gameplay happens
        
        //Game states will progress as follows:
        //start with the boot state, when the game first runs, we need to configure the screen size, and all other display information
        //this state handles screen set up, and nothing else
        var bootState = {
            
            //phaser allows users to specify special functiosn which are called during the game loop
            //for more information, check out: http://www.html5gamedevs.com/topic/1372-phaser-function-order-reserved-names-and-special-uses/
            create: function() {
                
                //define how the system should behave
                //use the arcade physics engine for collisin handling
                //I think p2 physics might be better because it offers pixel perfect collision detection, but we might not even need that so for now lets stick to somethign simple
                game.physics.startSystem(Phaser.Physics.ARCADE);
                
                //we're done with this state, so let's go onto the loading state to load the game resources
                game.state.start('load');
            },
        };
        
        //loading state should load ALL of the game's resources
        //this will cache (store in memory) all of the required pictures, sounds, level data for later use
        //this state is also where we generate the game world based on the players location
        //cached data will be saved to the global game object, so we can use it in later states
        var loadState = {
            
            //place to load files
            preload: function() {
                
                //loading is done using the following function
                //game.load.*   where * represents an object type to load
                //IMPORTANT: LOOK AT HOW WE GET THE PATH TO RESOURCE FILES, WE HAVE TO USE EMBED RUBY TO GENERATE THE PATH TO IT
                
                //load test player sprite sheet
                //remeber that the first parameter is always a hash key to refer to this object later
                //look at the documentation for all the parameters
                game.load.spritesheet('player', '<%= asset_path("roshan.png") %>', 32, 48);
                
                //since a player's game map is dependent on thier real world location, the map we load will depend on their location
                //so here is where we specify what map to load
                //we will assume mapWorldToGame will take a real world coordinate, and return an ingame map ID
                //we will also assume that all of our maps will be named mapI, where I is the map's id as a number
                
                //var mapId = mapWorldToGame(@player.realWorldLocation.x, @player.realWorldLocation.y);
                //var mapName = 'map' + mapId.toString();
                
                //now we load the tile set
                //tile maps will be created in the Tiled Level editor, which will give us a JSON file
                //we should use mapName instead of map.json, but we haven't created the map funcitonality so for now just use a preset level
                game.load.tilemap('level', '<%= asset_path("map.json") %>', null, Phaser.Tilemap.TILED_JSON);
                
                //we also want to load all the possible types of monsters in this level
                //we can assume that the getMonstersInMap will receive the name of a map, and returns the name of the file containing an array of monster names that can spawn on that map
                //These monster names will be used as keys into the mosnter database, and we will use it to retreive a given monster
                
                //var monsterListFile = getMonstersInMap(mapName)
                
                //now load this array for later use
                game.load.json('monsterList', '<%= asset_path("monsterList.json") %>');
                
                //now we have to load the actual mosnter database
                //this could also be stored in the server as a database, and we can use AJAX calls to receive the data
                //but for now i've saved all the mosnter data into app/assets/monsters/monsters.json
                game.load.json('monsterData', '<%= asset_path("monsters.json") %>');
                
                //now we would load all the images for the mosnters, but for now just load the orc image because i don't have any other mosnters
                game.load.spritesheet('orc','<%= asset_path("ifrit.png") %>', 80, 80);
                
                //the above just loads the json file, but doens't load the tileSheet (the images used to draw every single tile)
                //here we load the tile image
                //again we would be using the mapName variable if it was set up
                game.load.image('tileset', '<%= asset_path("TileSet.png") %>');
                
            },
            
            //create function creats the required object for this game state
            create: function() {
                
                //create a text that says loading
                //very simple loading screen
                var style = { font: "bold 32px Arial", fill: "#fff", boundsAlignH: "center", boundsAlignV: "middle"};
        		this.text = game.add.text(0, 0, "loading", style);
                
                //HERE IS WHERE WE WILL LOAD THE PLAYER
                //the player is created here and used in all later states
                player.sprite = game.add.sprite(0, 0, 'player', 0);
                
                //we want player to actually collide with stuff, so add a physcis body
                game.physics.arcade.enable(player.sprite);
                
                //modify the player's hitbox so it doesn't look like he is collidig with thin air
                player.sprite.body.setSize(26, 18, 3, 30);
                
                //prevent the player from leaving the world bounds, this means that player's can't walk off the edge of teh screen
                player.sprite.body.collideWorldBounds = true;
                
                //add all of the player's animations
        		player.sprite.animations.add('left', [4, 5, 6, 7], 10, true);
        		player.sprite.animations.add('right', [8, 9, 10, 11], 10, true);
        		player.sprite.animations.add('up', [12, 13, 14, 15], 10, true);
        		player.sprite.animations.add('down', [0, 1, 2, 3], 10, true);
        		player.sprite.animations.add('attack', [4, 5, 6, 7, 4, 5, 6, 7, 4], 7, false);
        		
        		//right now the player will draw onto the screen since phaser automatically draws all new sprites
        		//we want to not draw the player to the screen, so we remove him from phaser's rendering list
        		//also once the Load state finishes, the player's sprite will automatically be destoryed by phaser, 
        		//but we want to keep the sprite for the actual gameplay state
        		//by removing player from the object list, we prevent him from being drawn, as well as being destoryed.
        		game.world.remove(player.sprite);
        		
        		//all obejcts have been loaded and created, so now we can start the game
        		game.state.start('overworld');
            },
        };
        
        function someFunc(index) {
            
             document.getElementById("additional").innerHTML = this.monsters[index].health;
        }
        
        //the gameplay state
        //this is where the player will move around on the map
        //the technical term is overworld, so thats the name i will use for this state
        var overworldState = {
            
            generateTilemap: function() {
                
                //we already loaded the tilemap data in the load state, we just need to set them to a phaser object
                this.map = game.add.tilemap('level');
                
                //we have loaded the tile data, but we haven't given it an image to use
                //here we set an image for each tileset in the tilemap (a tileset is an image containing all of the tiles for a given level)
                //every map has different tile sets, and each of these tilesets have their own names, the names are set using Tiled level editor,
                //and they can be viewd in the map.json file, under tilesets: name:
                //here we match the name of the tileset, to the name of a preloaded tileset image
                //since i named the tileset and the image the same thing, you won't be able to tell which name refers to what
                //the first argument is the name of the tileset that was set in the Tiled level editor
                //the second argument is the key to an image that was loaded by in the load state
                this.map.addTilesetImage('TileSet', 'tileset');
                
                //the tilemaps have been created, but they won't draw until we turn them into viewable layers
                //create a layer for EVERY SINGLE layer in the actual tile map
                //i created two tile layers, the background layer and the solid layer
                //background layer is just the background, the solid layer are tiles that the player collides with
                //its important to have them seperate
                //though its not required
                
                //backround layer
                //the argument to the createLayer function is the name of the layer set by the Tiled level editor
                //the data for this layer can be viewed in the levle editor, or you can look at the map.json file
                this.background = this.map.createLayer('Background');
                this.solid = this.map.createLayer('solid');
                
                //the default game world size is the same as the canvas size
                //however we want the plaeyr ot be able to move around the entire world
                //so we must set the size of the gameworld to the size of the tilemap, that way the game world isn't too big or small
                this.background.resizeWorld();
                
                //phaser doesn't actually know anything about tile layers and collision, it just creates drawable tiles
                //now we need to specify that the tiles in the solid layer should actually collide with stuff
                //the first two arguments give a range of tile IDs that you want to set collision info to
                //the third argument sets whether or not the tile should collide
                //the last argument is the layer that you want to get tiles from
                this.map.setCollisionBetween(1, 10000, true, 'solid');
            },
            
            create: function() {
                
                //misc instructions, ignore
                document.getElementById("additional").innerHTML = "Use the arrow keys to move the player. Press Enter to enter battle";
        		
                //Phaser draws objects in the order they are created (all applications have a rendering order, this is jsut phaser's order)
                //this means that objects created first will be drawn underneath objects created last
                //so we need to create background objects first
                
                //first we will create the tile map
                this.generateTilemap();
                
                //now we create the player
                //we already created a player sprite, but we told phaser not to draw him
                //we need to add him back to the game world for drawing
                game.add.existing(player.sprite);
                
                //we also want he camera to follow the player
                game.camera.follow(player.sprite);
                
                //this function makes phaser use arrow keys for movement
                //it creates a collection of keys that you can poll for events (look at update function for polling code)
                //polling a key means you check if a key is pressed, or released
                this.cursors = game.input.keyboard.createCursorKeys();
                player.cursors = this.cursors;
                player.x = 0;
                
                //make phaser use a call back listener
                //listener functions are functions that are called whenever a certain action happens
                //here we want phaser to call a special function everytime a key is pressed down
                //first argument is the context where the call back functiosn are run
                //basically its what the name of the object that the 'this' variable in the listener function refers to
                //second argument is the function to call when a key is pressed
                //there are two more arguments that i haven't used yet
                game.input.keyboard.addCallbacks(this, this.handleKeyDown);
            },
            
            //update function is where the game world is updated
            //here we need to handle input, update physics, and handle collision
            //phaser does the physics and collision for us, we jst need to specify what collides
            update: function() {
                
                //NORMALLY we do input handling before all physics and collision
                //but phaser saves some data in the collision handling that we sometimes need in the input handling
                //so when working with phaser, we will do collision handling first
                
                //this funciton tells phaser to collide two objects, or two groups of objects
                //i haven't created a group of objects explicitly, but the tile map layer is a group of objects generated by phaser
                //this is why we need a seperate layer for background and solid, i only want my player to collide with fenses or houses
                //not the grass
                game.physics.arcade.collide(player.sprite, this.solid);
                
                //next handle all the game's inputs
                //start with keystate inputs, explained in the keystate function
                //we don't have to worry about button press events since we created listener for those events
                //but we can't create a listener for state events
                this.handleStateInputs();
                
                //now we want to see if the player randomly encountered an enemy, this will send us to the battle state
                //we only want to check if player encounterd an enemy if he moved
                //for now its commentd out since I didn't create the battle state
                //basically if hte player travels a certain distance, we check if he should battle an enemy
                /*if(player.sprite.body.deltaABSX() >= THRESHOLD || player.sprite.body.deltaABSY() >= THRESHOLD) {
                    
                    game.state.start('battle');
                }*/
            },
            
            handleStateInputs: function() {
                
                //input handling for player is done in this function
                //it might seem weird to have a function that jus calls another function
                //but this is a good way to organize your code for each section of the game.
                //we need to have a seperate section for input handling, so this function will contain all the code for input handling
                //but input handling can be broken down into different components, so each component will have its own input handling function
                this.handlePlayerKeystates();
                
                //after we can handle other key states, if there are any
            },
            
            handlePlayerKeystates: function() {
                
                //first we make player move and animate according to where he is moving
                //isDown is a bool value, that is true if the key is pressed down, and false otherwise
                //Checking if a key is pressed down or not is called checking a key state
                //Keystates only tell you if a button is pressed or not, 
                //it DOESN'T LET YOU HANDLE KEY PRESS EVENTS
                //this means if you want the player to attack when they press the attack button
                //if you check for keystate the game will make the player attack non stop, because you're not checking if the player pressed the attack button
                //you're only checking if the button is presed down
                //this might be confusing, but it'll make more sense with practice
                
                //for now disable diagnoal movement since i have no animation for diagnoal movement
                if((this.cursors.left.isDown || this.cursors.right.isDown) && (this.cursors.up.isDown || this.cursors.down.isDown)) {
                    
                    return;
                }
                
                if(this.cursors.left.isDown) {
                
                    //move left, the sprite has a variable called body
                    //this variable is a physics object that represents the object in the physics engine
                    //by setting its velocity we can make it move
                    player.sprite.body.velocity.x = -200;
                    
                    //run an animation, we created this animation already
                    player.sprite.animations.play('left');
                    
                } else if(this.cursors.right.isDown) {
                    
                    player.sprite.body.velocity.x = 200;
                    player.sprite.animations.play('right');
                    
                } else {
                    
                    //player isn't moving left or right, we have to set his velocity to 0 since the physcis engine isn't going to know when to stop moving
                    player.sprite.body.velocity.x = 0;
                    
                    //only stop animation if the player is moving left or right
                    //this is important because we don't want to stop animation when the player is moving up or down
                    //because the player will never animate then
                    if(player.sprite.animations.name == 'left' || player.sprite.animations.name == 'right') {
                        
                        //we stop the animation
                        //the first argument is the name of the animtion yo uwant to stop
                        //by setting to null, we stop the current animation
                        //second argument tells phaser we want to stop the animation and start drawing the first frame of the animation
                        //this way if player is standing still, he will face left or right, adn we won't have to determine which way he is facing
                        player.sprite.animations.stop(null, true);
                    }
                }
                
                if(this.cursors.up.isDown) {
                    
                    //IMPORTANT: IN COMPUTER GRAPHICS, THE POSTIIVE Y AXIS GOES DOWN, THE NEGATIVE Y AXIS GOES UP
                    //THIS MEANS THAT UPWARDS IS NEGATIVE
                    player.sprite.body.velocity.y = -200;
                    player.sprite.animations.play('up');
                    
                } else if(this.cursors.down.isDown) {
                    
                    player.sprite.body.velocity.y = 200;
                    player.sprite.animations.play('down');
                    
                } else {
                    
                    player.sprite.body.velocity.y = 0;
                    
                    if(player.sprite.animations.name == "up" || player.sprite.animations.name == 'down') {
                        
                        player.sprite.animations.stop(null, true);
                    }
                }
            },
            
            //function that we will send to phaser to handle key press events
            handleKeyDown: function(key) {
                
                //if user presses the enter key we will enter the battle state
                if(key.keyCode == Phaser.Keyboard.ENTER) {
                    
                    game.state.start('battle');
                }
            },
            
            
            //this function is called when we leave the currents tate
            //the battle state is a seperate state, and when we enter the battle state, this state will be destoryed
            //when this state is destoryed, all objects in this state will also be destoryed, hence the player is destoryed
            //we want to prevent that
            shutdown: function() {
                
                game.world.remove(player.sprite);
            },
        };
        
        //creates a text box at the given position
        //returns a Phaser Graphics object that represents the text box
        function createTextBox(x, y, width, height) {
            
            var box = game.add.graphics(x, y);
            
            //first create the colored rectangle
            var fillColor = 0x000099;
            box.beginFill(fillColor, 0.4);
            box.drawRect(0, 0, width, height);
            box.endFill();
            
            //now create a border around it to make it look nice
            var lineThickness = 3;
            var lineColor = 0x888888;
            
            box.lineStyle(lineThickness, lineColor, 0.8);
            box.x = x + lineThickness / 2;
            box.lineTo(width - lineThickness, 0);
            box.lineTo(width - lineThickness, height - lineThickness);
            box.lineTo(0, height - lineThickness);
            box.lineTo(0, 0);
            
            return box;
        };
       
        /*
        The following functions are meant to be added to the BATTLE STATE's subState manager for different states.
        the reason they are outside here is because i made a system in the battle state to easily add states and functions, but
        to do that you need to use premade functions
        functions delared as object properties are created at run time
        meaning i can't assign functions to objects if the functions are declared as object properties
        so i'm defining these functions outside here, instead of in teh battle state object
        
        These functions probably WILL NOT work outside of the battle state, because they all use properties declared inside the battle state object (using the this context reference)
        
        just pretend these functions are in the battle state, because when they're called, the context will be set to the battle state
        */
        function selectMainActionEnter() {
            
            this.mainActionsDisplay.selectedAction = 0;
            this.mainActionsDisplay.selectionDisplay.visible = true;
                    
            this.showMessage("Select an action");
        };
        
        function selectMainActionExit() {
            
            this.mainActionsDisplay.selectionDisplay.visible = false;
            this.hideMessage();
        };
        
        function selectMainActionKeyDown(key) {
            
            actionDisplayKeyDown(key, this.mainActionsDisplay);
            
            //execute the action the user has chosen
            if(key.keyCode == Phaser.Keyboard.ENTER) {
                
                //we would like to return to the main map if player selected run
                if(this.mainActionsDisplay.actionTexts[this.mainActionsDisplay.selectedAction].text == "run") {
                    
                    game.state.start('overworld');
                }
                
                if(this.mainActionsDisplay.actionTexts[this.mainActionsDisplay.selectedAction].text == "fight") {
                    
                    this.stateManager.changeState("selectFightAction");
                }
            }
        };
        
        function selectMainActionUpdate() {
            
            this.mainActionsDisplay.highlightSelectedAction();
        };
        
        function selectFightActionEnter() {
            
            this.fightActionsDisplay.selectedAction = 0;
            this.fightActionsDisplay.background.visible = true;
                    
            this.showMessage("Select an action");
        };
        
        function selectFightActionExit() {
            
            this.fightActionsDisplay.background.visible = false;
            this.hideMessage();
        };
        
        function selectFightActionKeyDown(key) {
            
            actionDisplayKeyDown(key, this.fightActionsDisplay);
                
            if(key.keyCode == Phaser.Keyboard.ENTER) {
                
                //we would like to return to the main map if player selected run
                if(this.fightActionsDisplay.actionTexts[this.fightActionsDisplay.selectedAction].text == "cancel") {
                    
                    this.stateManager.changeState("selectMainAction");
                }
                
                if(this.fightActionsDisplay.actionTexts[this.fightActionsDisplay.selectedAction].text == "attack" && this.monsters.length > 0) {
                    
                    this.stateManager.changeState("playerSelectTarget");
                }
            }
        };
        
        function selectFightActionUpdate() {
            
            this.fightActionsDisplay.highlightSelectedAction();
        };
        
        function playerSelectTargetEnter() {
            
            this.selectedMonsterId = 0;
            this.selectedMonsterIndicator.visible = true;
            this.showMessage("Select a monster to attack");
        };
        
        function playerSelectTargetExit() {
            
            this.selectedMonsterIndicator.visible = false;
            this.hideMessage();
        };
        
        function playerSelectTargetKeyDown(key) {
            
            if(key.keyCode == Phaser.Keyboard.UP) {
                
                this.selectedMonsterId -= 1;
                
                if(this.selectedMonsterId < 0) {
                    
                    this.selectedMonsterId = this.monsters.length - 1;
                }
            }
            
            if(key.keyCode == Phaser.Keyboard.DOWN) {
                
                this.selectedMonsterId = (this.selectedMonsterId + 1) % this.monsters.length;
            }
            
            if(key.keyCode == Phaser.Keyboard.ENTER) {
                
                this.stateManager.changeState("playerAttack");
            }
        };
        
        function playerSelectTargetUpdate() {
            
            this.highlightSelectedEnemy();
        };
        
        function playerAttackEnter() {
            
            this.showMessage("Attacking " + this.monsters[this.selectedMonsterId].name);
            
            //when player finishes his attack animation we will damage the enemy
            player.sprite.events.onAnimationComplete.add(function(){this.stateManager.changeState("playerAttackResults"); }, this);
            player.sprite.animations.play("attack");
            
            player.lastUsedAttack.power = player.strength;
        };
        
        function playerAttackExit() {
            
            player.sprite.events.onAnimationComplete.removeAll();
            this.hideMessage();
        };
        
        
        function playerAttackResultsEnter() {
            
            var damage = this.determineAttackResults(player, this.monsters[this.selectedMonsterId]);
            
                    //get damage received by this entity
            this.damageTexts.push(this.createDamageText(this.monsters[this.selectedMonsterId], damage) );
        };
        
        function playerAttackResultsExit() {
            
            this.clearDamageTexts();
            this.hideMessage();
        };
        
        function playerAttackResultsUpdate() {
            
            var moveToNextState = this.finishedDisplayingResults();
            
            if(moveToNextState) {
                
                this.stateManager.changeState("cullDeadEnemies");
            }
        };
    
        function cullDeadEnemiesEnter() {
            
            this.killDeadEnemies();
        };
    
        function cullDeadEnemiesExit() {
            
            this.hideMessage();
        };
        
        function cullDeadEnemiesUpdate() {
            
            var removedAllMarkedEntites = this.deleteMarkedEntities(this.monsters);
                    
            if(removedAllMarkedEntites && this.monsters.length == 0) {
                
                //go to victory
                this.stateManager.changeState("selectMainAction");
            }
            
            if(removedAllMarkedEntites && this.monsters.length > 0) {
                
                //enemy turn start
                this.stateManager.changeState("enemyTurnStart");
            }
        };
        
        function enemyTurnStartEnter() {
            
            this.currentEnemy = 0;
        };
        
        function enemyTurnStartExit() {
            
            this.hideMessage()
        };
        
        function enemyTurnStartUpdate() {
            
            
            if(this.monsters.length == 0) {
                
                this.stateManager.changeState("selectMainAction");
                
            } else {
                
                this.stateManager.changeState("enemyTurn");
            }
        };
        
        function enemyTurnEnter() {
            
            //randomly determine what the enemy should do
            //for now he just attacks
            this.monsters[this.currentEnemy].sprite.events.onAnimationComplete.add(function(){this.stateManager.changeState("enemyAttackResults"); } , this);
            this.monsters[this.currentEnemy].sprite.animations.play("attack");
            this.monsters[this.currentEnemy].lastUsedAttack.power = this.monsters[this.currentEnemy].strength;
            
            this.showMessage(this.monsters[this.currentEnemy].name + " attacks!");
        };
        
        function enemyTurnExit() {
            
            if(this.currentEnemy < this.monsters.length) {
                
                this.monsters[this.currentEnemy].sprite.events.onAnimationComplete.removeAll();
            }

            this.hideMessage();
        };
        
        function enemyAttackResultsEnter() {
            
            var damage = this.determineAttackResults(this.monsters[this.currentEnemy], player);
            this.damageTexts.push(this.createDamageText(player, damage) );
        };
        
        function enemyAttackResultsExit() {
            
            playerAttackResultsExit.call(this);
        };
        
        function enemyAttackResultsUpdate() {
            
            var moveToNextState = this.finishedDisplayingResults();
            
            if(!moveToNextState) {
                
                return;
            }
            
            this.currentEnemy += 1;
            
            //no more enemies, move back to player's turn
            if(this.currentEnemy >= this.monsters.length) {
            
                this.stateManager.changeState("selectMainAction");
                return;
            }
            
            //enemy left, start his turn
            this.stateManager.changeState("enemyTurn");
        };
        
        //the battle state
        //here players will battle some number of monsters
        var battleState = {
            
            //load the data of the monsters the player has to fight
            loadMonsters: function() {
                
                //here is where the monsters list we loaded previously, and the mosnter database come into play
                //we want to randomly generate a mosnter, so we will randomly select the name of a mosnter that can spawn in this map
                //generate the array of mosnter names
                //the getJSON function uses a key to a previously loaded json file
                //it then returns a java script object containing the data loaded in the file
                //please look up how JSON works if you are unfamiliar with it
                var monsterNames = game.cache.getJSON('monsterList');
                
                //now we want to randomly select a monster name from this list
                //the object basiclaly has 1 element named monsters, which is an array of names
                //these names are actually keys to the database, so we can use it directly
                //randomly select monster name (for now just use the orc name since i haven't created the others)
                var id = 0;
                var monsterName = monsterNames.monsters[id];
                
                //now we can use this key to load the monster data
                //first turn the monster database to a javascript object
                var monsterDatabase = game.cache.getJSON('monsterData');
                
                //now get the monster with the above key
                //if you don't understand this notation, please search up javascript objects: http://www.w3schools.com/js/js_object_definition.asp, and follow the next 3 tutorials
                var monster = new rpgEntity();
                $.extend(monster, monsterDatabase[monsterName]);
                monster.x = 200;
                monster.y = 300;
                
                return [monster];
            },
            
            generateMonsterSprites: function(monsters) {
                
                //all monsters have a key that can be used to get the name of the sprite for the monster
                //lets get this monsters image to draw
                //we can position the mosnter for battle as well
                var i = 0;
                for(i = 0; i < monsters.length; ++i) {
                    
                    monsters[i].sprite = game.add.sprite(monsters[i].x, monsters[i].y, monsters[i].imageKey, monsters[i].startingFrame);
                    
                    for(var j = 0; j < monsters[i].animations.length; ++j) {
                        
                        animation = monsters[i].animations[j];
                        monsters[i].sprite.animations.add(animation.name, animation.frames, animation.speed, false);
                    }
                }
            },
            
            //saves the orientation of the player as it was in the overworld state, before the battle started
            //this is needed so we can restore the player back to his original position when the battle ends
            savePlayerOverworldOrientation: function() {
                
                this.playerPositionX = player.sprite.x;
                this.playerPositionY = player.sprite.y;
                this.playerAnimation = player.sprite.animations.name;
            },
            
            //loads the players overworld position so that he ends up exactly where he was before the battle started
            loadPlayerOverworldOrientation: function() {
                
                player.sprite.x = this.playerPositionX;
                player.sprite.y = this.playerPositionY;
                player.sprite.animations.play(this.playerAnimation);
                player.sprite.animations.stop(null, true);
            },
            
            //positions the player in the battle screen
            orientPlayerForBattle: function() {
                
                player.sprite.x = 500;
                player.sprite.y = 300;
                
                player.sprite.body.velocity.x = 0;
                player.sprite.body.velocity.y = 0;
                
                //player face left
                player.sprite.animations.play('left');
                player.sprite.animations.stop(null, true);
            },
            
            //draws a rectangle around the monster that the player has currently chosen to attack
            highlightSelectedEnemy: function() {
            
                //first clear the previously drawn selection
                this.selectedMonsterIndicator.clear();
                
                if(this.selectedMonsterId >= this.monsters.length) {
                    
                    return;
                }
                
                //set line style
                this.selectedMonsterIndicator.lineStyle(2, 0xff0000, 1);
                
                //make sure the selected mosnter exists
                this.selectedMonsterId = clamp(this.selectedMonsterId, 0, this.monsters.length);
                
                var xPosition = this.monsters[this.selectedMonsterId].sprite.x;
                var yPosition = this.monsters[this.selectedMonsterId].sprite.y;
                var width = this.monsters[this.selectedMonsterId].sprite.width;
                var height = this.monsters[this.selectedMonsterId].sprite.height;
                
                this.selectedMonsterIndicator.drawRect(xPosition, yPosition, width, height);
            },
            
            showMessage: function(message) {
                
                this.textBox.visible = true;
                this.text.setText(message);
            },
            
            hideMessage: function() {
                
                this.textBox.visible = false;
            },
            
            //makes the attacker attack the defender
            //determines if the attack hit the defender
            //determines damage dealt
            //returns a string
            determineAttackResults: function(attacker, defender) {
                
                var damage = determineDamage(attacker.lastUsedAttack.power, defender.defense);
                defender.getHit(damage);
                return damage;
            },
            
            //creates a damage text that displays the amount of damage the given entity received
            createDamageText: function(entity, damageReceived) {
                
                var damageText = new Object();
                damageText.text = game.add.text(entity.sprite.width / 2, 0, damageReceived.toString(), {fill: 'red'});
                damageText.text.alpha = 0.3;
                damageText.text.anchor.setTo(0.5, 0);
                
                entity.sprite.addChild(damageText.text);
                
                var textTween = game.add.tween(damageText.text).to({y: -40, alpha: 1}, 1000, Phaser.Easing.Bounce.Out);
                textTween.start();
                
                damageText.tween = textTween;
                
                return damageText;
            },
            
            clearDamageTexts: function() {
                
                var i = 0;
                
                for(i = 0; i < this.damageTexts.length; i++) {
                    
                    this.damageTexts[i].text.destroy();
                }
                
                this.damageTexts = [];
            },
            
            //checks if all of the attack results texts have finished their tweening
            finishedDisplayingResults: function() {
                
                //if any text is still tweening, then we have to wait for it to finish
                var i = 0;
                
                for(i = 0; i < this.damageTexts.length; i++) {
                    
                    
                    if(this.damageTexts[i].tween.isRunning) {
                        
                        return false;
                    }
                    
                }

                return true;
            },
            
            //looks for all dead enemies and plays their dying animation
            killDeadEnemies: function() {
                
                for(var i = 0; i < this.monsters.length; i++) {
                    
                    if(this.monsters[i].health != 0) {
                        
                        continue;
                    }
                    
                    killEntity(this.monsters[i]);
                }
            },
            
            //deletes all entities marked for deletion
            //returns true if all dead entities have been deleted
            //false if there are entities that are still animating, and need to be deleted later
            deleteMarkedEntities: function(entities) {
                
                for(var i = 0; i < entities.length;) {
                    
                    if(entities[i].health != 0) {
                        
                        i += 1;
                        continue;
                    }

                    if(!entities[i].shouldDelete) {
                        
                        return false;
                    }
                    
                    entities[i].sprite.destroy();
                    entities.splice(i, 1);
                    
                }
                return true;
            },
            
            //this object is where you should define all of the substates of the battle system
            //any substate added here will be autoamtically added to the state manager
            subStates: [
                
                //use as follows
                //any sub state you want to add, create a new object in this
                //each state object needs to itself be an object, containing two attributes, a name as a string, and an object containing all of the functions
                //the id of each function should be the name you want to give the function after it is turned into a state object
                
                //example
                //this state is for players to select a main action, either fight, run, or use items
                {name: "selectMainAction", //name of the state
                    functions: { //list of functions available in this state
                        //in this state i want to add a function called onEnter.
                        //i want onEnter to refer to the selectMainActionEnter function declared above
                        onEnter: selectMainActionEnter,  //attribute name is the name i want to give the function. Attribute value is the function itself
                        onExit: selectMainActionExit,    //create a function called onExit. the function that is actually called will be the selectMainActionExit function declared above
                        onKeyDown: selectMainActionKeyDown,
                        onUpdate: selectMainActionUpdate,
                    }
                },
                
                //any time you want to add a new state, just add it like in the example above
                {name: "selectFightAction",
                    functions: {
                        
                        onEnter: selectFightActionEnter,
                        onExit: selectFightActionExit,
                        onKeyDown: selectFightActionKeyDown,
                        onUpdate: selectFightActionUpdate
                    }
                },
                
                {name: "playerSelectTarget",
                    functions: {
                        
                        onEnter: playerSelectTargetEnter,
                        onExit: playerSelectTargetExit,
                        onKeyDown: playerSelectTargetKeyDown,
                        onUpdate: playerSelectTargetUpdate
                    }
                },
                
                {name: "playerAttack",
                    functions: {
                        
                        onEnter: playerAttackEnter,
                        onExit: playerAttackExit
                    }
                },
                
                {name: "playerAttackResults",
                    functions: {
                        
                        onEnter: playerAttackResultsEnter,
                        onExit: playerAttackResultsExit,
                        onUpdate: playerAttackResultsUpdate
                    }
                },
                
                {name: "cullDeadEnemies",
                    functions: {
                        
                        onEnter: cullDeadEnemiesEnter,
                        onExit: cullDeadEnemiesExit,
                        onUpdate: cullDeadEnemiesUpdate
                    }
                },
                
                {name: "enemyTurnStart",
                    functions: {
                        
                        onEnter: enemyTurnStartEnter,
                        onExit: enemyTurnStartExit,
                        onUpdate: enemyTurnStartUpdate
                    }
                },
                
                {name: "enemyTurn",
                    functions: {
                        
                        onEnter: enemyTurnEnter,
                        onExit: enemyTurnExit
                    }
                },
                
                {name: "enemyAttackResults",
                    functions: {
                        
                        onEnter: enemyAttackResultsEnter,
                        onExit: enemyAttackResultsExit,
                        onUpdate: enemyAttackResultsUpdate
                    }
                }
                
            ],
            
            createSubStates: function() {
                
                this.stateManager = new stateManager();
                
                //go through all the states and add them
                for(var i = 0; i < this.subStates.length; ++i) {
                    
                    var state = new subState();
                    
                    //set the functions for this state
                    for(functionName in this.subStates[i].functions) {
                        
                        state.addFunction(functionName, this.subStates[i].functions[functionName], this);
                    }
                    
                    //add to state manager
                    this.stateManager.addState(this.subStates[i].name, state);
                }
            },
            
            create: function() {
                
                //misc instructions, ignore
                document.getElementById("additional").innerHTML = "select an action";
                
                var style = { font: "bold 32px Arial", fill: "#fff", boundsAlignH: "center", boundsAlignV: "middle"};
        		this.text = game.add.text(0, 0, "BATTLe", style);
        		
                //first we have to create a background to display
                //i haven't put in any background yet but just know that it has to be created first
                
                //next we will create a monster
                //we might have a battle with multiple monsters, so the name is plural
                //although right now it generates a single monster, later it might create an array of monsters
                this.monsters = this.loadMonsters();
                
                //we've only loaded the data for the mosnter, we now need to create an image so we can see them
                this.generateMonsterSprites(this.monsters);
                
                //now we want to reload the player
                game.add.existing(player.sprite);
                
                //we also have to reposition the player since we are starting a battle
                //when we exit the battle, the player will be at a different position than when he started, so we need to save the players old position and orientation
                this.savePlayerOverworldOrientation();
                
                //set player to battle position, and orientation
                this.orientPlayerForBattle();
                
                //now we want to have some UI to display all the battle options
                
                //first we have to create the box where the UI is displayed
                //if you look at final fantasy battles, there are blue rectangles that contain all the text
                //first is the rectangle that contains all the actions the player can take
                
                var actionBoxWidth = game.scale.width;
                var actionBoxHeight = 130;
                
                //create the main actions
                /*this.actionBox = this.createActionBox(0, game.scale.height - actionBoxHeight, actionBoxWidth, actionBoxHeight, ['fight', 'items', 'run']);
                
                //create the options that show up if player selects to fight
                this.fightBox = this.createActionBox(game.scale.width / 3, game.scale.height - actionBoxHeight - 20, game.scale.width / 3, actionBoxHeight, ['attack', 'skills', 'cancel']);
                this.fightBox.actionsContainer.visible = false;*/
                
                this.mainActionsDisplay = new actionDisplay(0, game.scale.height - actionBoxHeight, actionBoxWidth, actionBoxHeight, ['fight', 'items', 'run']);
                this.fightActionsDisplay = new actionDisplay(game.scale.width / 3, game.scale.height - actionBoxHeight - 20, game.scale.width / 3, actionBoxHeight, ['attack', 'skills', 'cancel']);
                
                //again we want to add a listener for when the player presses on keys
                game.input.keyboard.callbackContext = this;
                game.input.keyboard.onDownCallback = this.onKeyDown;
                
                //when the player starts to attack we need a way for the player to select a mosnter to attack
                //this variable keeps track of what mosnter the player has selected
                this.selectedMonsterId = 0;
                
                //this graphics object will draw a rectangle around the selected mosnter
                this.selectedMonsterIndicator = game.add.graphics(0, 0);
                
                //we need a way to give messages to the player
                //we will create a text box at the top of the screen, it will only be visible when there is a message for the player to read
                this.textBox = createTextBox(0, 0, game.scale.width, 50);
                
                //now create a text that will be displayed
                //these settings make the text centerd to the message box
                this.text = game.add.text(0, 0, "Message");
                this.text.x = this.textBox.width / 2;
                this.text.anchor.x = 0.5;
                this.text.fill = 'white';
                this.textBox.addChild(this.text);
                
                //this contains text that will display the amount of damage an enemy or player received after an attack
                //new text is added to it whenever an entity is damaged, and once the text finishes displaying, it will be deleted
                //damage texts will contain the text reprsenting the damage, and a phaser tween object
                //tween objects represent a linear interpolation between two object states, we will use it to animate the text
                this.damageTexts = [];
                
                
                this.createSubStates();
                this.stateManager.exitAll();
                this.stateManager.changeState("selectMainAction");
            },
            
            update: function() {
            
                this.stateManager.onUpdate();
            },
            
            onKeyDown: function(key) {
                
                this.stateManager.onKeyDown(key);
            },
            
            //this is a render (drawing) function
            //phaser draws all of our game objects automatically, however we might want to do our own rendering calls
            //in the render function we dont do any calculations at all
            //all math, physics, updating, should be done in the update function
            //only draw calls should be placed in this function
            render: function() {
                
                //i want to draw the selection box as a rectangle, since phaser doesn't do it automatically
                //we need to postiion the rectangle around the current selection, but in the render function we only draw, no calculations should be done here
            },
            
            shutdown: function() {
                
                //now we also want the player ot return to whatever he was doing, so set him back to his original position
                this.loadPlayerOverworldOrientation();
                
                //once again we don't want the game to destroy the player
                game.world.remove(player.sprite);
            },
        };
        
        //register all of the gameplay states
        game.state.add('boot', bootState);
        game.state.add('load', loadState);
        game.state.add('overworld', overworldState);
        game.state.add('battle', battleState);
        
        //now run the boot state, which will call load and overworld as needed
        game.state.start('boot');
        
        
    </script>
</div>